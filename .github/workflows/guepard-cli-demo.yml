name: Guepard CLI Demo Scenarios

on:
  workflow_dispatch: # Allow manual triggering

jobs:
  # Job 1: Build the custom image with all dependencies
  build-custom-image:
    name: Build Dependency Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # To push to GHCR
    outputs:
      # Correctly format output for GHCR path
      image_tag: ghcr.io/${{ github.repository_owner }}/guepard-demo-runner:${{ github.sha }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Dockerfile for Runner
        run: |
          cat <<'EOF' > Dockerfile.runner
          FROM ubuntu:24.04

          # --- 1. Install System Prerequisites ---
          ENV DEBIAN_FRONTEND=noninteractive
          RUN apt-get update && apt-get install -y --no-install-recommends \
              build-essential procps curl file git ca-certificates sudo \
              unzip # Bun dependency

          # --- 2. Install Bun Globally (as root) ---
          RUN curl -fsSL https://bun.sh/install | bash
          # Add Bun to global PATH for all users
          ENV PATH="/root/.bun/bin:${PATH}"

          # --- 3. Install Homebrew & Guepard CLI (as linuxbrew user) ---
          # Create linuxbrew user, grant passwordless sudo for installation steps
          RUN useradd -ms /bin/bash linuxbrew && \
              echo "linuxbrew ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers.d/linuxbrew && \
              chmod 0440 /etc/sudoers.d/linuxbrew

          # Switch to linuxbrew to install Homebrew
          USER linuxbrew
          WORKDIR /home/linuxbrew

          # Install Homebrew
          RUN /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

          # Add Homebrew to PATH for linuxbrew user and subsequent RUN commands AS linuxbrew
          ENV PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:${PATH}"

          # Install Guepard CLI using Homebrew
          RUN brew tap guepard-corp/guepard && brew install guepard

          # Create Guepard session directory (owned by linuxbrew)
          RUN mkdir -p /home/linuxbrew/.guepard

          # --- 4. Create Application User ---
          USER root # Switch back to root
          ARG APP_USER=appuser
          ARG APP_UID=1001
          RUN groupadd --gid $APP_UID $APP_USER || true # Allow group to exist
          RUN useradd --uid $APP_UID --gid $APP_USER --create-home --shell /bin/bash $APP_USER
          # Optional: Grant specific sudo permissions if appuser needs them later,
          # but avoid NOPASSWD: ALL for the app user if possible.

          # --- 5. Install Application Dependencies (as appuser) ---
          # Set main working directory and permissions
          WORKDIR /app
          RUN chown $APP_USER:$APP_USER /app

          # Switch to the application user
          USER $APP_USER
          WORKDIR /app # Ensure WORKDIR is set for the app user

          # Copy backend dependency files and install
          COPY --chown=$APP_USER:$APP_USER ./components/api/package.json ./components/api/bun.lockb* ./components/api/
          WORKDIR /app/components/api
          # Ensure Bun (installed globally as root) is accessible via PATH
          # If PATH isn't inherited correctly, add ENV PATH="/root/.bun/bin:${PATH}" again before USER appuser
          RUN bun install --frozen-lockfile

          # Generate Prisma Client
          RUN bunx prisma generate

          # Copy frontend dependency files and install
          WORKDIR /app # Go back to root app dir before copying next part
          COPY --chown=$APP_USER:$APP_USER ./components/frontend/package.json ./components/frontend/bun.lockb* ./components/frontend/
          WORKDIR /app/components/frontend
          RUN bun install --frozen-lockfile
          # --- End Dependency Installation ---

          # --- 6. Final Configuration ---
          # Copy rest of the application code (will be owned by appuser)
          # Note: This invalidates Docker cache more often, but ensures latest code is present
          # Could be done AFTER checkout in the job instead if preferred.
          WORKDIR /app
          COPY --chown=$APP_USER:$APP_USER ./components /app/components
          COPY --chown=$APP_USER:$APP_USER ./demo /app/demo

          # Set default workdir and user for container execution
          WORKDIR /app
          USER $APP_USER

          # Expose ports (optional, docker run/compose handles mapping)
          # EXPOSE 3001 5173

          # Default command if needed, but ENTRYPOINT/CMD usually comes from docker run/compose
          # CMD ["sleep", "infinity"]

          EOF

      - name: Normalize repository owner name # Use owner instead of full repo
        id: repo_owner_lc
        run: echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Define Image Tag
        id: image_tag_def
        run: echo "image_tag=ghcr.io/${{ steps.repo_owner_lc.outputs.owner_lc }}/guepard-demo-runner:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.runner
          push: true
          tags: ${{ steps.image_tag_def.outputs.image_tag }} # Use the defined tag
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 2: Run CLI Scenario 1 using the custom image
  safe-feature-development-cli:
    name: Scenario 1 (CLI) - Safe Feature Development
    runs-on: ubuntu-latest
    needs: build-custom-image # Depends on the image being built
    container: # Use the image built in the previous job
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env: # Environment variables available inside the container
        DATABASE_URL: ${{ secrets.GUEPARD_DB_URL }}
        SHADOW_DATABASE_URL: ${{ secrets.GUEPARD_SHADOW_DB_URL }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }} # Pass token for login
        # Separate secret for the feature branch URL is needed for migrate step
        GUEPARD_FEATURE_DB_URL: ${{ secrets.GUEPARD_FEATURE_DB_URL }}
    steps:
      - name: Checkout Code # Check out into container's /app directory
        uses: actions/checkout@v4
        with:
          path: '.' # Checkout to the current WORKDIR (/app)

      - name: Set ownership of checked-out files
        # Checkout runs as root, switch ownership to 'bun' user
        run: sudo chown -R bun:bun /app

      - name: Login to Guepard (inside container)
        run: |
          # Use 'gp' directly as it's installed in the image's PATH
          echo "Logging into Guepard..."
          gp login --token "$GUEPARD_API_KEY"
          echo "Verifying login..."
          gp usage

      # --- Scenario Steps ---
      - name: 1. Ensure Main Branch is Clean & Baseline
        # Run prisma commands from the correct directory within /app
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and schema is baseline..."
          # gp branch switch main # May not be needed if DB_URL points to main
          echo "Applying migrations to main..."
          bunx prisma migrate deploy # Ensure main is up-to-date
          # Add baselining logic here if necessary

      - name: 2. Create Feature Branch in Guepard
        run: |
          BRANCH_NAME="feature-discounts-cli-${{ github.run_id }}"
          echo "Creating Guepard branch '$BRANCH_NAME'..."
          gp branch create "$BRANCH_NAME" --from main
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV # Save for cleanup step
          sleep 5

      - name: 3. Apply Code Patch Locally (inside container)
        run: |
          echo "Applying 'discount-feature' file patch..."
          chmod +x ./demo/demo-manager.sh
          # Script assumes it runs from demo/, paths inside use ../
          cd demo
          ./demo-manager.sh apply discount-feature
          cd .. # Go back to /app

      - name: 4. Apply Migration to Feature Branch
        working-directory: /app/components/api # Prisma commands run here
        env: # Override DATABASE_URL just for migration
           DATABASE_URL: ${{ env.GUEPARD_FEATURE_DB_URL }}
        run: |
          echo "Applying migrations to '${{ env.BRANCH_NAME }}' branch..."
          # Resolve baseline if needed for new branches in Guepard
          # BASELINE_MIGRATION_ID=$(ls -t prisma/migrations | grep 'baseline' | head -n 1) # Example
          # bunx prisma migrate resolve --applied $BASELINE_MIGRATION_ID
          echo "Deploying migrations..."
          bunx prisma migrate deploy

      - name: 5. Verify Schema Change via CLI (Optional)
        run: |
          echo "Verifying 'discount_price' column on branch '${{ env.BRANCH_NAME }}'..."
          # Use gp query or psql (psql is installed in the image)
          # Example with psql requires DB details, safer to use gp query
          gp query "SELECT column_name FROM information_schema.columns WHERE table_schema='public' AND table_name='products' AND column_name='discount_price';" --branch "${{ env.BRANCH_NAME }}"
          # Add check for output here if needed

      - name: 6. Cleanup
        if: always() # Run even if previous steps fail
        run: |
          echo "Cleaning up..."
          gp branch switch main
          if [ -n "${{ env.BRANCH_NAME }}" ]; then
            echo "Deleting branch ${{ env.BRANCH_NAME }}..."
            gp branch delete "${{ env.BRANCH_NAME }}" -f
          fi

  # Job 3: Run CLI Scenario 2 using the custom image
  data-time-travel-cli:
    name: Scenario 2 (CLI) - Data Time Travel
    runs-on: ubuntu-latest
    needs: build-custom-image # Depends on the image
    container: # Use the same image
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env:
        DATABASE_URL: ${{ secrets.GUEPARD_DB_URL }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }}
    steps:
      - name: Checkout Code # ...
        uses: actions/checkout@v4
        with:
          path: '.'
      - name: Set ownership of checked-out files # ...
        run: sudo chown -R bun:bun /app

      - name: Login to Guepard (inside container) # ...
        run: |
          gp login --token "$GUEPARD_API_KEY"
          gp usage

      # --- Scenario Steps ---
      - name: 1. Ensure Main Branch and Seed Data
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and seeding data..."
          # gp branch switch main
          # Reset and seed for a known state
          bunx prisma migrate reset --force
          bunx prisma db seed
          echo "Checking for initial product..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 1 ]; then echo "Seed data not found!"; exit 1; fi

      - name: 2. Simulate Data Deletion
        run: |
          echo "Deleting product..."
          gp query "DELETE FROM products WHERE name = 'Wireless Headphones';" --branch main
          sleep 2

      - name: 3. Verify Deletion
        run: |
          echo "Verifying product deletion..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 0 ]; then echo "Product deletion failed!"; exit 1; fi
          echo "Product successfully deleted."

      - name: 4. Perform Time Travel Revert
        run: |
          echo "Performing time travel revert (e.g., 1 minute ago)..."
          gp revert main --to "1 minute ago" # Replace with actual command
          sleep 5

      - name: 5. Verify Restoration
        run: |
          echo "Verifying product restoration..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 1 ]; then echo "Product restoration failed!"; exit 1; fi
          echo "Product successfully restored via time travel!"
