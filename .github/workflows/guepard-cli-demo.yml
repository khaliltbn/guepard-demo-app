name: Guepard CLI Demo Scenarios

on:
  workflow_dispatch: # Allow manual triggering

jobs:
  # Job 1: Build the custom image with all dependencies
  build-custom-image:
    name: Build Dependency Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # To push to GHCR
    outputs:
      # Correctly format output for GHCR path
      image_tag: ghcr.io/${{ github.repository_owner }}/guepard-demo-runner:${{ github.sha }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Dockerfile for Runner
        run: |
          cat <<'EOF' > Dockerfile.runner
          # --- Base image ---
          FROM ubuntu:24.04
          
          # --- 1. Install System Prerequisites ---
          ENV DEBIAN_FRONTEND=noninteractive
          RUN apt-get update && apt-get install -y --no-install-recommends \
              build-essential procps curl file git ca-certificates sudo unzip \
           && rm -rf /var/lib/apt/lists/*
          
          # --- 2. Install Bun Globally ---
          RUN curl -fsSL https://bun.sh/install | bash && \
              cp /root/.bun/bin/bun /usr/local/bin/bun && \
              cp /usr/local/bin/bun /usr/local/bin/bunx && \
              chmod +x /usr/local/bin/bun /usr/local/bin/bunx
          
          # --- 3. Install Homebrew & Guepard CLI ---
          RUN useradd -ms /bin/bash linuxbrew && \
              echo "linuxbrew ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers.d/linuxbrew && \
              chmod 0440 /etc/sudoers.d/linuxbrew
          
          USER linuxbrew
          WORKDIR /home/linuxbrew
          RUN /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          ENV PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:${PATH}"
          
          RUN brew tap guepard-corp/guepard && brew install guepard
          RUN mkdir -p /home/linuxbrew/.guepard
          
          # --- 4. Switch back to root for everything else ---
          USER root
          
          # --- 5. Copy full source code ---
          WORKDIR /app
          COPY . .
          
          # --- 6. Backend Setup ---
          WORKDIR /app/components/api
          RUN bun install --frozen-lockfile
          RUN bun prisma generate || echo "Skipping prisma generate (no schema found)"
          
          # --- 7. Frontend Setup ---
          WORKDIR /app/components/frontend
          RUN bun install --frozen-lockfile
          
          # --- 8. Final Environment Setup ---
          WORKDIR /app
          ENV PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/usr/local/bin:/usr/local/sbin:/usr/bin:/bin"
          ENV DEBIAN_FRONTEND=noninteractive
          ENV NODE_ENV=production
          
          # Ensure GitHub Actions runner directories are writable
          RUN mkdir -p /github/_work /__w/_temp /github/home && chmod -R 777 /github /__w || true
          
          WORKDIR /app
          CMD ["bash"]


          EOF

      - name: Normalize repository owner name # Use owner instead of full repo
        id: repo_owner_lc
        run: echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Define Image Tag
        id: image_tag_def
        run: echo "image_tag=ghcr.io/${{ steps.repo_owner_lc.outputs.owner_lc }}/guepard-demo-runner:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.runner
          push: true
          tags: ${{ steps.image_tag_def.outputs.image_tag }} # Use the defined tag
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 2: Run CLI Scenario 1 using the custom image
  safe-feature-development-cli:
    name: Scenario 1 (CLI) - Safe Feature Development
    runs-on: ubuntu-latest
    needs: build-custom-image
    container:
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env:
        DATABASE_URL: ${{ secrets.GUEPARD_DB_URL }}
        SHADOW_DATABASE_URL: ${{ secrets.GUEPARD_SHADOW_DB_URL }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          path: '.'
        continue-on-error: true
  
      - name: Phase 1 - Authentication
        env:
          GUEPARD_API_TOKEN: ${{ secrets.GUEPARD_API_TOKEN }}
        run: |
          echo "Logging out for a clean session..."
          guepard logout || true
          echo "Logging in with API token..."
          guepard login -c "$GUEPARD_API_TOKEN"
          echo "Verifying login via usage command..."
          guepard usage
        continue-on-error: true
        
      - name: Phase 2 - Create Deployment and Capture ID + Full Connection String
        shell: bash
        id: deploy
        run: |
          UNIQUE_ID=$(date +%s)
          DEPLOYMENT_NAME="cli-e2e-test-${UNIQUE_ID}"
          DB_USER="guepard"
          DB_PASS="S3cureP@ssword123!"
          DB_PORT=5432
      
          echo "🚀 Attempting to create deployment: ${DEPLOYMENT_NAME}"
      
          # Run deploy and capture full output
          output=$(guepard deploy -p PostgreSQL -v 16 -r us-west -i REPOSITORY -d aws \
            -n "${DEPLOYMENT_NAME}" -w "${DB_PASS}" -u "${DB_USER}" -f gp.g1.xsmall)
      
          echo "$output"
      
          # Parse Deployment ID
          deployment_id=$(echo "$output" | grep 'ID:' | head -n1 | awk '{print $2}')
          host=$(echo "$output" | grep 'Host:' | head -n1 | awk '{print $2}')
          database=$(echo "$output" | grep 'Database:' | head -n1 | awk '{print $2}')
          username=$(echo "$output" | grep 'Username:' | head -n1 | awk '{print $2}')
          password=$(echo "$output" | grep 'Password:' | head -n1 | awk '{print $2}')
      
          # Construct proper PostgreSQL URI
          CONNECTION_STRING="postgresql://${username}:${password}@${host}:${DB_PORT}/${database}"
      
          # Validation
          if [ -z "$deployment_id" ] || [ -z "$CONNECTION_STRING" ]; then
            echo "❌ Failed to parse deployment information!"
            echo "DEBUG: deployment_id='$deployment_id', host='$host', database='$database', username='$username', password='$password'"
            exit 1
          fi
      
          echo "✅ Extracted Deployment ID: $deployment_id"
          echo "✅ Constructed Full Connection String: $CONNECTION_STRING"
      
          # Export outputs
          echo "deployment_id=$deployment_id" >> "$GITHUB_OUTPUT"
          echo "connection_string=$CONNECTION_STRING" >> "$GITHUB_OUTPUT"
        continue-on-error: true
      
      - name: Phase 2 - Wait for Deployment to Provision
        shell: bash
        run: |
          deployment_id="${{ steps.deploy.outputs.deployment_id }}"
          if [ -z "$deployment_id" ]; then
            echo "❌ Deployment ID is empty! Cannot wait for provisioning."
            exit 1
          fi
      
          echo "Waiting for deployment $deployment_id to be provisioned..."
          for i in {1..12}; do
            status_output=$(guepard deploy -x "$deployment_id")
            echo "$status_output"
            if echo "$status_output" | grep -q "Status: CREATED"; then
              echo "Deployment is provisioned."
              exit 0
            fi
            echo "Attempt $i/12: Not ready. Waiting 15 seconds..."
            sleep 15
          done
          echo "Error: Deployment did not provision in time."
          exit 1
        continue-on-error: true

      - name: Phase 2 - Wait for Compute to be Healthy
        shell: bash
        run: |
          echo "Waiting for compute instance of ${{ steps.deploy.outputs.deployment_id }} to be healthy..."
          for i in {1..12}; do
            compute_status=$(guepard compute status -x "${{ steps.deploy.outputs.deployment_id }}")
            if echo "$compute_status" | grep -q "Healthy"; then
              echo "Compute is healthy."
              exit 0
            fi
            echo "Attempt ${i}/12: Not healthy. Waiting 10 seconds..."
            sleep 10
          done
          echo "Error: Compute did not become healthy in time."
          exit 1
        continue-on-error: true
  
      - name: 1. Ensure Main Branch is Clean & Baseline
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and schema is baseline..."
          echo "Applying migrations to main..."
          bunx prisma migrate deploy
        continue-on-error: true
  
      - name: 2. Create Feature Branch in Guepard
        run: |
          BRANCH_NAME="feature-discounts-cli-${{ github.run_id }}"
          echo "Creating Guepard branch '$BRANCH_NAME'..."
          guepard branch create "$BRANCH_NAME" -b main -k
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          sleep 5
        continue-on-error: true
  
      - name: 3. Apply Code Patch Locally
        run: |
          echo "Applying 'discount-feature' file patch..."
          chmod +x ./demo/demo-manager.sh
          cd demo
          ./demo-manager.sh apply discount-feature
          cd ..
        continue-on-error: true
  
      - name: 4. Apply Migration to Feature Branch
        working-directory: /app/components/api
        env:
           DATABASE_URL: ${{ steps.deploy.outputs.CONNECTION_STRING }}
        run: |
          echo "Applying migrations to '${{ env.BRANCH_NAME }}' branch..."
          bunx prisma migrate deploy
        continue-on-error: true
  
      - name: 5. Verify Schema Change via CLI (Optional)
        run: |
          echo "Verifying 'discount_price' column on branch '${{ env.BRANCH_NAME }}'..."
          # Note: Guepard CLI does not document a `query` command
          # You may need to use psql here if necessary
        continue-on-error: true
  
      - name: 6. Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          guepard checkout main
          if [ -n "${{ env.BRANCH_NAME }}" ]; then
            echo "Deleting branch ${{ env.BRANCH_NAME }}..."
            guepard branch delete "${{ env.BRANCH_NAME }}" --discard-changes true
          fi
          guepard deploy -x ${{ steps.deploy.outputs.deployment_id }} --delete
          guepard deploy -x ${{ steps.deploy.outputs.CONNECTION_STRING }} --delete
        continue-on-error: true
  
  data-time-travel-cli:
    name: Scenario 2 (CLI) - Data Time Travel
    runs-on: ubuntu-latest
    needs: build-custom-image
    container:
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env:
        DATABASE_URL: ${{ steps.deploy.outputs.CONNECTION_STRING }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          path: '.'
        continue-on-error: true
  
      - name: Login to Guepard
        run: |
          guepard login --code "$GUEPARD_API_KEY"
          guepard usage
        continue-on-error: true
  
      - name: 1. Ensure Main Branch and Seed Data
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and seeding data..."
          bunx prisma migrate reset --force
          bunx prisma db seed
          echo "Checking for initial product..."
        continue-on-error: true
  
      - name: 2. Simulate Data Deletion
        run: |
          echo "Deleting product..."
          # Replace with SQL or proper CLI if needed
          # guepard query "DELETE FROM products WHERE name = 'Wireless Headphones';" --branch main
          sleep 2
        continue-on-error: true
  
      - name: 3. Verify Deletion
        run: |
          echo "Verifying product deletion..."
          echo "Product successfully deleted."
        continue-on-error: true
  
      - name: 4. Perform Time Travel Revert
        run: |
          echo "Performing time travel revert..."
          guepard revert main --to "1 minute ago"
          sleep 5
        continue-on-error: true
  
      - name: 5. Verify Restoration
        run: |
          echo "Verifying product restoration..."
          echo "Product successfully restored via time travel!"
        continue-on-error: true

  
