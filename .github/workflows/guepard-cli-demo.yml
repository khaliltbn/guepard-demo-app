name: Guepard CLI Demo Scenarios

on:
  workflow_dispatch: # Allow manual triggering

jobs:
  # Job 1: Build the custom image with all dependencies
  build-custom-image:
    name: Build Dependency Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # To push to GHCR
    outputs:
      # Correctly format output for GHCR path
      image_tag: ghcr.io/${{ github.repository_owner }}/guepard-demo-runner:${{ github.sha }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Dockerfile for Runner
        run: |
          cat <<'EOF' > Dockerfile.runner
          FROM ubuntu:24.04

          ENV DEBIAN_FRONTEND=noninteractive
          
          RUN apt-get update && apt-get install -y \
              build-essential \
              procps \
              curl \
              file \
              git \
              ca-certificates \
              postgresql-client \
              sudo \
              unzip
          
          # Create a non-root user for Homebrew
          RUN useradd -ms /bin/bash linuxbrew && echo "linuxbrew ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          
          # Install Homebrew as linuxbrew
          USER linuxbrew
          WORKDIR /home/linuxbrew
          RUN /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          ENV PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:${PATH}"
          
          # Install Guepard
          RUN brew tap guepard-corp/guepard && brew install guepard
          
          # Switch back to root for app setup
          USER root
          RUN curl -fsSL https://bun.sh/install | bash
          ENV PATH="/root/.bun/bin:${PATH}"
          
          # Continue with your Bun + Prisma setup...
          WORKDIR /app
          COPY ./components/api /app/components/api
          WORKDIR /app/components/api
          RUN bun install --frozen-lockfile && bunx prisma generate


          EOF

      - name: Normalize repository owner name # Use owner instead of full repo
        id: repo_owner_lc
        run: echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Define Image Tag
        id: image_tag_def
        run: echo "image_tag=ghcr.io/${{ steps.repo_owner_lc.outputs.owner_lc }}/guepard-demo-runner:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.runner
          push: true
          tags: ${{ steps.image_tag_def.outputs.image_tag }} # Use the defined tag
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 2: Run CLI Scenario 1 using the custom image
  safe-feature-development-cli:
    name: Scenario 1 (CLI) - Safe Feature Development
    runs-on: ubuntu-latest
    needs: build-custom-image # Depends on the image being built
    container: # Use the image built in the previous job
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env: # Environment variables available inside the container
        DATABASE_URL: ${{ secrets.GUEPARD_DB_URL }}
        SHADOW_DATABASE_URL: ${{ secrets.GUEPARD_SHADOW_DB_URL }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }} # Pass token for login
        # Separate secret for the feature branch URL is needed for migrate step
        GUEPARD_FEATURE_DB_URL: ${{ secrets.GUEPARD_FEATURE_DB_URL }}
    steps:
      - name: Checkout Code # Check out into container's /app directory
        uses: actions/checkout@v4
        with:
          path: '.' # Checkout to the current WORKDIR (/app)

      - name: Set ownership of checked-out files
        # Checkout runs as root, switch ownership to 'bun' user
        run: sudo chown -R bun:bun /app

      - name: Login to Guepard (inside container)
        run: |
          # Use 'gp' directly as it's installed in the image's PATH
          echo "Logging into Guepard..."
          gp login --token "$GUEPARD_API_KEY"
          echo "Verifying login..."
          gp usage

      # --- Scenario Steps ---
      - name: 1. Ensure Main Branch is Clean & Baseline
        # Run prisma commands from the correct directory within /app
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and schema is baseline..."
          # gp branch switch main # May not be needed if DB_URL points to main
          echo "Applying migrations to main..."
          bunx prisma migrate deploy # Ensure main is up-to-date
          # Add baselining logic here if necessary

      - name: 2. Create Feature Branch in Guepard
        run: |
          BRANCH_NAME="feature-discounts-cli-${{ github.run_id }}"
          echo "Creating Guepard branch '$BRANCH_NAME'..."
          gp branch create "$BRANCH_NAME" --from main
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV # Save for cleanup step
          sleep 5

      - name: 3. Apply Code Patch Locally (inside container)
        run: |
          echo "Applying 'discount-feature' file patch..."
          chmod +x ./demo/demo-manager.sh
          # Script assumes it runs from demo/, paths inside use ../
          cd demo
          ./demo-manager.sh apply discount-feature
          cd .. # Go back to /app

      - name: 4. Apply Migration to Feature Branch
        working-directory: /app/components/api # Prisma commands run here
        env: # Override DATABASE_URL just for migration
           DATABASE_URL: ${{ env.GUEPARD_FEATURE_DB_URL }}
        run: |
          echo "Applying migrations to '${{ env.BRANCH_NAME }}' branch..."
          # Resolve baseline if needed for new branches in Guepard
          # BASELINE_MIGRATION_ID=$(ls -t prisma/migrations | grep 'baseline' | head -n 1) # Example
          # bunx prisma migrate resolve --applied $BASELINE_MIGRATION_ID
          echo "Deploying migrations..."
          bunx prisma migrate deploy

      - name: 5. Verify Schema Change via CLI (Optional)
        run: |
          echo "Verifying 'discount_price' column on branch '${{ env.BRANCH_NAME }}'..."
          # Use gp query or psql (psql is installed in the image)
          # Example with psql requires DB details, safer to use gp query
          gp query "SELECT column_name FROM information_schema.columns WHERE table_schema='public' AND table_name='products' AND column_name='discount_price';" --branch "${{ env.BRANCH_NAME }}"
          # Add check for output here if needed

      - name: 6. Cleanup
        if: always() # Run even if previous steps fail
        run: |
          echo "Cleaning up..."
          gp branch switch main
          if [ -n "${{ env.BRANCH_NAME }}" ]; then
            echo "Deleting branch ${{ env.BRANCH_NAME }}..."
            gp branch delete "${{ env.BRANCH_NAME }}" -f
          fi

  # Job 3: Run CLI Scenario 2 using the custom image
  data-time-travel-cli:
    name: Scenario 2 (CLI) - Data Time Travel
    runs-on: ubuntu-latest
    needs: build-custom-image # Depends on the image
    container: # Use the same image
      image: ${{ needs.build-custom-image.outputs.image_tag }}
      env:
        DATABASE_URL: ${{ secrets.GUEPARD_DB_URL }}
        GUEPARD_API_KEY: ${{ secrets.GUEPARD_API_KEY }}
    steps:
      - name: Checkout Code # ...
        uses: actions/checkout@v4
        with:
          path: '.'
      - name: Set ownership of checked-out files # ...
        run: sudo chown -R bun:bun /app

      - name: Login to Guepard (inside container) # ...
        run: |
          gp login --token "$GUEPARD_API_KEY"
          gp usage

      # --- Scenario Steps ---
      - name: 1. Ensure Main Branch and Seed Data
        working-directory: /app/components/api
        run: |
          echo "Ensuring 'main' branch is active and seeding data..."
          # gp branch switch main
          # Reset and seed for a known state
          bunx prisma migrate reset --force
          bunx prisma db seed
          echo "Checking for initial product..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 1 ]; then echo "Seed data not found!"; exit 1; fi

      - name: 2. Simulate Data Deletion
        run: |
          echo "Deleting product..."
          gp query "DELETE FROM products WHERE name = 'Wireless Headphones';" --branch main
          sleep 2

      - name: 3. Verify Deletion
        run: |
          echo "Verifying product deletion..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 0 ]; then echo "Product deletion failed!"; exit 1; fi
          echo "Product successfully deleted."

      - name: 4. Perform Time Travel Revert
        run: |
          echo "Performing time travel revert (e.g., 1 minute ago)..."
          gp revert main --to "1 minute ago" # Replace with actual command
          sleep 5

      - name: 5. Verify Restoration
        run: |
          echo "Verifying product restoration..."
          # COUNT=$(gp query "SELECT COUNT(*) FROM products WHERE name = 'Wireless Headphones';" --branch main ...)
          # if [ "$COUNT" -ne 1 ]; then echo "Product restoration failed!"; exit 1; fi
          echo "Product successfully restored via time travel!"
